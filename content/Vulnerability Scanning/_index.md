+++
title = "Vulnerability Scanning"
date = 2019-07-08T13:08:10+01:00
weight = 3
chapter = true
pre = "<b>3. </b>"
draft = false
+++

Typically, BigCo's usual strategy regarding penetration testing is to align it closely to release schedules. Given the mandate from the CEO, though, this doesn't quite work:

If you wish to align to release schedules, you'll have to actually define a schedule, which then allows you to request time from your third-party penetration testers. Unfortunately, this lends itself to "big bang" releases, where lots of features are rolled in to one. If there's a failure, you'll need to revert the entire release! You can't be doing this given your mandate, but regularly scheduling a penetration test is an expensive process that your team doesn't have budget for each time it wishes to do a release (often, multiple times per week).

You speak to the Office of the CISO at BigCo about using a vulnerability scanner, instead. In this model, you propose, rather than using third-party external pentetration testers for every release, you instead use a software vulnerability scanner any time anyone makes a change. Optionally, the business can then decide to keep its regular cadence of penetration tests separately. BigCo's Office of the CISO agrees that this makes sense, and lets you start including [OWASP](https://owasp.org) ZAP, the Zed Attack Proxy, in your CI pipeline.

If the tests go well, it'll be mandated across other teams.

### Installation

Jenkins is extensible through plug-ins. A number of plug-ins exist for installing and managing ZAP through Jenkins. As you dig around, you find a number don't work particularly well, or have other vulnerabilities within! You start to look through Jenkins to see what options you have to hand using native plug-ins:

1. On the left, click Manage Jenkins
1. Click Manage Plugins
1. Click the Available tab
1. Using the Filter box, search for `ZAP`

At this stage, you'll likely notice that one of the plugins has a security vulnerability reported against it. This serves as a good reminder that we should keep on top of our dependencies! We'll steer well clear of the plugin storing credentials in plain text. Unfortunately, the other plugins listed also have issues - one has an issue where ZAP can't be started because, and another has essentially been abandoned!

With a colleague, you decide that the best course of approach is to install ZAP, and a way to manage ZAP programatically, using your existing configuration management tools. Let's assume that this work has been done. You decide to use [zap-cli](https://github.com/Grunny/zap-cli) for management of ZAP.

## Configuration

Configuration of ZAP is via `zap-cli`, as discussed above. But, we want to configure this in code, as we have done all throughout today. To do that, add the following snippet in to your `Jenkinsfile`:

```
stage('Scan for vulnerabilities') {
    steps {
        sh 'java -jar dvja-*.war & && PID=$! && zap-cli quick-scan --self-contained --spider -r http://127.0.0.1 && zap-cli report -o zap-report.html -f html && kill $PID'
    }
}
```

This step is a little more complicated than we've used before, and contains some Bashisms. Let's work through them:

- `java -jar dvja-*.war` starts any WAR file beginning `dvja-` using the Java Virtual Machine installed on the Jenkins server
- `&` makes the above task a background process, so that it runs in the background and we can work on other processes in front
- `&& PID=$!` grabs the Process ID for the backgrounded process, such that we can kill it later on
- The `zap-cli` commands perform scanning using ZAP against the running Java application
- `kill $PID` kills the Java process we started, returning us to our neutral state

Outside of the `stages` block, add another block, as follows:

```
post {
    always {
        archiveArtifacts artifacts: 'zap-report.html', fingerprint: true
    }
}
```

Run the Jenkins job. You should notice that it takes a little longer this time - firstly, it will want to start the packaged software up, and then it will make use of Zap to scan for vulnerabilities, before writing these to a report. Jenkins tracks these reports over builds, so that we can perform trend analysis.

On the Jenkins job home page, click the name of the latest archived report to download it. Take a look inside, and see what Zap found.